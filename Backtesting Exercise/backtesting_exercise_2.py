# -*- coding: utf-8 -*-
"""Backtesting Exercise 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ENNuLZLgT6-yr6lIRn7W63NbuKMQm613
"""

pip install pandas_ta

import pandas as pd
import numpy as np
import pandas_ta as ta
import matplotlib.pyplot as plt

mydf = pd.DataFrame()
mydf.ta.indicators()
# if need help on a indicator
# help(indicator_name)

"""- download prices data from an online source
- load data into framework
- check and clean data content
- quick statistical analysis to reveal hidden patterns
"""

from google.colab import files
uploaded = files.upload()

df = pd.read_csv('USDCHF_Candlestick_4_Hour_BID_05.05.2003-19.10.2019.csv')
df.tail()

# Check for zero volume rows
indexZeros = df[df['Volume'] == 0].index

df.drop(indexZeros, inplace = True)
df.loc[(df['Volume'] == 0)]
df.isna().sum()

# to see which indicators are available for this df
# df.ta.indicators()

# average true range (last 20 bars)
df['ATR'] = df.ta.atr(length = 20)
# relative strength index (no parameters, default 14 bars)
df['RSI'] = df.ta.rsi()
# mid price of bar for each bar
df['Average'] = df.ta.midprice(length = 1) #midprice
# Common practice to consider 3 moving averages sensitivities in fx
# larger duration = less sensitive
df['SMA40'] = df.ta.sma(length=40)
df['SMA80'] = df.ta.sma(length=80)
df['SMA160'] = df.ta.sma(length=160)

# fits line through data points
from scipy.stats import linregress
def get_slope(array):
  y = np.array(array)
  x = np.arange(len(y))
  slope, intercept, r_value, p_value, std_err = linregress(x, y)
  return slope

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# taking last 6 values of each feature to calculate the slope
# could increase this as a variable, 6 is a good enough number to guess the trend of each of these features
backrollingN = 6
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
df['slopeSMA40'] = df['SMA40'].rolling(window = backrollingN).apply(get_slope, raw = True)
df['slopeSMA80'] = df['SMA80'].rolling(window = backrollingN).apply(get_slope, raw = True)
df['slopeSMA160'] = df['SMA160'].rolling(window = backrollingN).apply(get_slope, raw = True)
df['AverageSlope'] = df['Average'].rolling(window=backrollingN).apply(get_slope, raw=True)
df['RSISlope'] = df['RSI'].rolling(window=backrollingN).apply(get_slope, raw=True)

"""- still have starting columns
- added ATR RSI midprice SMA and slopes
- negative slope heading downwards
- positive slope heading upwards
"""

df.tail()

"""# Target categories
- hard part is defining your target
- lots of people try to guess future price for next few days: Too ambitious?
- much easier to define categories for your target:
  - if price will go up 100 pips, down 100 pips, or remain same
  - category 0: unclear trend
  - category 1: downward trend
  - category 2: upward trend
"""

#Target flexible way
pipdiff = 500*1e-5 #for TP
SLTPRatio = 2 #pipdiff/Ratio gives SL

def mytarget(barsupfront, df1):
    length = len(df1)
    high = list(df1['High'])
    low = list(df1['Low'])
    close = list(df1['Close'])
    open = list(df1['Open'])
    trendcat = [None] * length
    
    for line in range (0,length-barsupfront-2):
        valueOpenLow = 0
        valueOpenHigh = 0
        for i in range(1,barsupfront+2):
            value1 = open[line+1]-low[line+i]
            value2 = open[line+1]-high[line+i]
            valueOpenLow = max(value1, valueOpenLow)
            valueOpenHigh = min(value2, valueOpenHigh)

            if ( (valueOpenLow >= pipdiff) and (-valueOpenHigh <= (pipdiff/SLTPRatio)) ):
                trendcat[line] = 1 #-1 downtrend
                break
            elif ( (valueOpenLow <= (pipdiff/SLTPRatio)) and (-valueOpenHigh >= pipdiff) ):
                trendcat[line] = 2 # uptrend
                break
            else:
                trendcat[line] = 0 # no clear trend
            
    return trendcat

# when running this function mytarget
# add results to mytarget column
df['mytarget'] = mytarget(16, df)
df.head()

"""#Quick analysis example"""

# used to take quick look at your data
# to see if you ahve outliers or weird data

#import matplotlib.pyplot as plt
fig = plt.figure(figsize = (15,20))
# fig.gca() = get current axes
# can then get subplots
ax = fig.gca()
df_model= df[['Volume', 'ATR', 'RSI', 'Average', 'SMA40', 'SMA80', 'SMA160', 'slopeSMA40', 'slopeSMA80', 'slopeSMA160', 'AverageSlope', 'RSISlope', 'mytarget']] 
df_model.hist(ax = ax)
plt.show()

"""For mytarget bar graph
- notice how uptrend(2) and downtrend(1) are pretty similar in frequency
- however, no trend (0) is slightly higher frequency (should be taken into account, if going to fit into ML model)

# Use RSI alone as trend indicator?
"""

#import matplotlib.pyplot as plt
#filter them based on conditions and store them into corresponding new dataframes
df_up = df.RSI[df['mytarget'] == 2]
df_down = df.RSI[df['mytarget'] == 1]
df_unclear = df.RSI[df['mytarget'] == 0]
#plot histograms for 3 categories
plt.hist(df_unclear, bins = 100, alpha = 0.5, label = 'unclear')
plt.hist(df_down, bins = 100, alpha = 0.5, label = 'down')
plt.hist(df_up, bins = 100, alpha = 0.5, label = 'up')
plt.legend(loc = 'upper right')
plt.show()

"""- RSI are symmetrical
- no visible difference between 3 histograms
  - 3 trend categories will same values with same probabilities for RSI
    - quite deceiving
    - cannot guess price trend solely based on RSI

# Backtesting Candlestick Strategy

#### Followed Youtube tutorial by CodeTrading
#### https://youtu.be/eN4zh3PEH6c
- doji -> undecided
- shooting star -> see it during uptrend -> trend reversal?
- hammer -> see during uptrend -> trend reversal?
- bullish engulfing -> during downtrend -> potential uptrend after
- bearish engulfing -> during uptrend -> potential downtrend after
- 3 crows?
--------------------
- specifically interested in hammer, or shooting star here
- code this pattern into python
- backtest candlestick strategy to see if it's a winning indicator or random
- when see hammer, sell signal
- (high - open) / body > certain ratio1 (2x higher, 3x? 4x?)
  - test it
- body = open - close
- don't want lower tail to be too big
  - (close - low) / (high - open) < ratio2 (0.5x? 0.25x? of long tail)
-------------------
For buy signal (hammer?):
- same approach, take symmetrical values
- using candlesticks not really enough to get accurate buy/sell signals
- combined with favorite indicator, here use RSI
- candlestick + some technical indicator (or fundamental indicator)

Need stop loss signal
- SL = price - ATR
  - common use of ATR (to decide where stop loss will be)
  - not too close to trigger often, nor too far which will lead to big losses
  - volatile market then ATR will be larger so SL far from price, no volatility then small ATR so SL close to price
- TP = price + TPSLRatio * ATR
  - take profit
  - TPSLRatio = 2 for this case, so take profit is twice as far as stop loss so every winning trade will make up for every 2 losing trades

- calculate SL, then calculate TP, then run program
- given TPSLRatio = 2, each win makes up for 2 losses, so we need to have win rate > 33-34% of the time to have winning system (doesn't include costs of trade)
"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
df = pd.read_csv('USDJPY_Candlestick_1_D_ASK_05.05.2003-19.10.2019.csv')
df.tail()

# test is volume = 0 b/c these are days something wrong in data itself?
indexZeros = df[df['Volume'] == 0].index

df.drop(indexZeros, inplace = True)
df.loc[(df['Volume'] == 0)]
df.dropna(inplace = True)

df.isna().sum()

df.tail()

pip install pandas_ta

import numpy as np
import pandas_ta as ta
#df.ta.indicators()
#help(ta.atr)

# strategy needs ATR and RSI so add into df

# length = 10 last 10 days
df['ATR'] = df.ta.atr(length=10)
# default last 14 days for RSI
df['RSI'] = df.ta.rsi()

#for down trends
# shooting star

# define function that takes df and provides back signal (buy/sell) according to candlestick pattern
def Revsignal1(df1):
  df.dropna()
  # reset_index b/c when dropna, index won't be consecutive numbers
  df.reset_index(drop = True, inplace = True)

  length = len(df1)
  high = list(df1['High'])
  low = list(df1['Low'])
  close = list(df1['Close'])
  open = list(df1['Open'])
  # 0 value list of same length of dataframe
  signal = [0] * length
  highdiff = [0] * length
  lowdiff = [0] * length
  bodydiff = [0] * length
  ratio1 = [0] * length
  ratio2 = [0] * length

  #start analysis in this function
  for row in range(0, length):

    # highest value - max(open and close) = length of high tail above body
    highdiff[row] = high[row] - max(open[row], close[row])
    # length of body
    bodydiff[row] = abs(open[row] - close[row])
    # b/c bodydiff will affect calculation, don't want 0
    # just in case open price = close price, 0.002 chose randomly
    # cannot go below 0.002
    if bodydiff[row] < 0.002:
      bodydiff[row] = 0.002
    # length of small tail below body
    lowdiff[row] = min(open[row], close[row]) - low[row]
    # long tail length / body length
    ratio1[row] = highdiff[row] / bodydiff[row]
    # low tail length / body length
    ratio2[row] = lowdiff[row] / bodydiff[row]

  # start looking for sell signal (shooting star)
  # length of upper tail / length of body > 2.5 and
  # low tail shorter than 1/3 of upper tail
  # 0.3 and 2.5? parameters you can optimize on your own
  # to have shooting star form, makes sense to choose ratio1 > 2
  # low tail can be 0.2 or 0.3
  # don't want small body, so want bodydiff > 0.03
  # RSI btwn 50 and 70 b/c below 50 may mean oversold
  # > 70 might indicate strong upward trend
    if (ratio1[row] > 2.5 and lowdiff[row] < 0.3 * highdiff[row] and bodydiff[row] > 0.03 and df.RSI[row] > 50 and df.RSI[row] < 70):
      # sell signal category = 1
      signal[row] = 1
  
  #elif (ratio2[row-1]>2.5 and highdiff[row-1]<0.23*lowdiff[row-1] and bodydiff[row-1]>0.03 and bodydiff[row]>0.04 and close[row]>open[row] and close[row]>high[row-1] and df.RSI[row]<55 and df.RSI[row]>30):
  # signal[row] = 2
  # _|_
  # |__|
  #  |
  #  |

  # not symmetrical to sell signal, detecting buying signal
  # symmetrical form. < 55 but > 30
  # very interesting. market is not symmetrical. cannot use same conditions for selling bot and buying bot
  # optimize selling and buying in independent way
    elif (ratio2[row] > 2.5 and highdiff[row] <0.23 * lowdiff[row] and bodydiff[row] > 0.03 and df.RSI[row] < 55 and df.RSI[row] > 30):
      signal[row] = 2
  return signal

df['signal1'] = Revsignal1(df)
# how many buying signals 
df[df['signal1']==2].count()

# 36 selling signals for 16 years
df[df['signal1']==1].count()

# now to test the strategy
# define new function

# Target Shooting Star
# starting from a certain position or a certain candle stick
# this function will look to number of bars up front, and check if price will touch stop loss
# first or take profit first
# in this case, we define if we have a winning/losing trade
# 
def mytarget(barsupfront, df1):
  length = len(df1)
  high = list(df1['High'])
  low = list(df1['Low'])
  close = list(df1['Close'])
  open = list(df1['Open'])
  datr = list(df1['ATR'])
  trendcat = [None] * length

  for line in range(0, length - barsupfront - 1):
    valueOpenLow = 0
    valueOpenHigh = 0

    highdiff = high[line] - max(open[line], close[line])
    bodydiff = abs(open[line] - close[line])

    # stop loss given here
    # gap between price and stop loss is provided by pipdiff
    pipdiff = datr[line]*1. #highdiff * 1.3 # for SL 400 * 1e-3
    # for trade to be valid, there must be a minimum for the stop loss, cannot be too close to price
    if pipdiff < 1.1:
      pipdiff = 1.1

    # defines gap between price and TP value
    SLTPRatio = 2 #pipdiff * Ratio gives TP

    for i in range(1, barsupfront + 1):
      value1 = close[line] - low[line + i]
      value2 = close[line] - high[line + i]
      valueOpenLow = max(value1, valueOpenLow)
      valueOpenHigh = min(value2, valueOpenHigh)

      if ((valueOpenLow >= (SLTPRatio * pipdiff)) and (-valueOpenHigh < pipdiff)):
        trendcat[line] = 1 #-1 downtrend
        break
      elif ((valueOpenLow < pipdiff)) and (-valueOpenHigh >= (SLTPRatio*pipdiff)):
        trendcat[line] = 2 #uptrend
        break
      else:
        trendcat[line] = 0 #no clear trend
  return trendcat

#mytarget(barsfront to take into account, dataframe)
df['Trend'] = mytarget(100, df)
df.tail(20)

"""Want to check signal was =1 (sell) and the real trend also =1
- % of time our signaling was correct
- for buy signals: signal = 2 and number of times signaling was correct, trend also = 2
"""

# set list of conditions
# trend & signal = 1 or trend & signal = 2
conditions = [(df['Trend'] == 1) & (df['signal1'] == 1),
              (df['Trend'] == 2) & (df['signal1'] == 2)]
values = [1, 2]
# store values in result column
df['result'] = np.select(conditions, values)

# test precision of each category signaling on its own

trendId=2
# # of times we had true positive sell signal / total number of sell signals
print(df[df['result']==trendId].result.count()/df[df['signal1']==trendId].signal1.count())
df[ (df['result']!=trendId) & (df['signal1']==trendId) ] # false positives

#histrs = df[ (df['result']==2) & (df['signal1']==2) ].RSI # false positives
#import matplotlib.pyplot as plt
#plt.hist(histrs,bins=2)  # density=False would make counts
#plt.ylabel('Probability')
#plt.xlabel('RSI');

"""Anything above 34% is a winner b/c SLTPRatio = 2
- can also print 
"""

dfpl = df[400:480]
import plotly.graph_objects as go
from datetime import datetime

fig = go.Figure(data=[go.Candlestick(x=dfpl.index,
                open=dfpl['Open'],
                high=dfpl['High'],
                low=dfpl['Low'],
                close=dfpl['Close'])])

fig.show()

