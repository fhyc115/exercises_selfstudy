# -*- coding: utf-8 -*-
"""Backtesting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FkFtIm3q38JF4-gsfV_F2v5riiXLGGkg
"""

# backtrader doesn't seem to work?
# pip install backtrader

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# # two main components to backtrader script
# # strategy class
# # cerebro engine

# import backtrader as bt

# class MyStrategy(bt.Strategy):
#   def next(self):
#     pass # Do something

# #Instantiate Cerebro engine
# cerebro = bt.Cerebro()

# #Add strategy to Cerebro
# cerebro.addstrategy(MyStrategy)

# #Run Cerebro Engine
# cerebro.run()

"""Cerebro Engine = core of Backtrader
* main class & will add our data and strategies to it before eventually calling the cerebro.run() command

### Get data and import it into Backtrader

1. API from broker to get historical data
2. many 3rd party APIs that allow you to download historical data from within your Python Console
3. Yahoo Finance CSV data download

`log` function allows us to pass in data via the `txt` variable that we want to output to the scren.
- will attempt to grab `datetime` values from the most recent data point, if available, and log it to the screen.
- overwrite `next` function now that printing/logging fn defined.
  - most important part of strategy as most of our code will get executed here.
  - this part gets called every time Backtrader iterates over the next new data point
"""

# from datetime import datetime
# # Create a subclass of Strategy to define the indicators and logic

# class SmaCross(bt.Strategy):
#     # list of parameters which are configurable for the strategy
#     params = dict(
#         pfast=10,  # period for the fast moving average
#         pslow=30   # period for the slow moving average
#     )

#     def __init__(self):
#         sma1 = bt.ind.SMA(period=self.p.pfast)  # fast moving average
#         sma2 = bt.ind.SMA(period=self.p.pslow)  # slow moving average
#         self.crossover = bt.ind.CrossOver(sma1, sma2)  # crossover signal

#     def next(self):
#         if not self.position:  # not in the market
#             if self.crossover > 0:  # if fast crosses slow to the upside
#                 self.buy()  # enter long

#         elif self.crossover < 0:  # in the market & cross to the downside
#             self.close()  # close long position


# cerebro = bt.Cerebro()  # create a "Cerebro" engine instance

# # Create a data feed
# data = bt.feeds.YahooFinanceData(dataname='AMD.csv',
#                                  fromdate=datetime(2011, 1, 1),
#                                  todate=datetime(2012, 12, 31))

# cerebro.adddata(data)  # Add the data feed

# cerebro.addstrategy(SmaCross)  # Add the trading strategy
# cerebro.run()  # run it all
# cerebro.plot()  # and plot it with a single command

from google.colab import files
uploaded = files.upload()

pip install backtesting

"""--------------------------------------------------

# Backtesting.py

best suited for optimizing position entrance and exit signal strategies, decisions upon values of technical indicators, and it's also a versatile interactive trade visualization and statistics tool.
- bring your own data. Backtesting ingests _all kinds of OHLC data_ (stocks, forex, futures, crypto, ...) as a pandas.DataFrame with columns `'Open'`, `'High'`, `'Low'`, `'Close'` and (optionally) `'Volume'`
- Besides these, your data frames can have additional columns which are accessible in your strategies in a similar manner.
"""

# Example OHLC daily data for Google Inc.
# 2004 - 2013 data
from backtesting.test import GOOG

GOOG.head()

"""### Strategy
create first strategy to backtest on these Google data, a SMA cross-over strategy.
- backtesting.py doesn't ship own set of technica analysis indicators.
- users favoring TA should refer to functions from proven indicator libraries, such as `TA-Lib` or `Tulipy`
"""

import pandas as pd

def SMA(values, n):
  '''
  return SMA of 'values', at each step taking into account `n` previous values.
  '''
  return pd.Series(values).rolling(n).mean()

"""new strategy needs to extend `Strategy` class and override its two abstract methods: `init()` and `next()`.

method `init()` is invoked before the strategy is run. Within it, one ideally precomputes in efficient, vectorized manner whatever indicators and signlas the strategy depends on 

method `next()` is then iteratively called by the `Backtest` instance once for each data point (data frame row) simulating the incremental availability of each new full candlestick bar.

Note, backtesting cannot make decisions / trades within candlesticks -- any new orders are executed on the next candle's open (or the current candle's close if `trade_on_close = True`). If you find yourself wishing to trade within candlesticks(e.g. day_trading) you instead need to begin with more fine-grained (e.g. hourly) data
"""

from backtesting import Strategy
from backtesting.lib import crossover


class SmaCross(Strategy):
    # Define the two MA lags as *class variables*
    # for later optimization
    n1 = 10
    n2 = 20
    
    def init(self):
        # Precompute the two moving averages
        self.sma1 = self.I(SMA, self.data.Close, self.n1)
        self.sma2 = self.I(SMA, self.data.Close, self.n2)
    
    def next(self):
        # If sma1 crosses above sma2, close any existing
        # short trades, and buy the asset
        if crossover(self.sma1, self.sma2):
            self.position.close()
            self.buy()

        # Else, if sma1 crosses below sma2, close any existing
        # long trades, and sell the asset
        elif crossover(self.sma2, self.sma1):
            self.position.close()
            self.sell()

"""In `init()` as well as `next()`, the data the strategy is simulated on is available as an instance variable `self.data`.

In `init()`, we declare and compute indicators indirectly by wrapping them in `self.I()`. The wrapper is passed a function (our `SMA` function) along with any arguments to call it with (our close values and the MA lag). Indicators wrapped in this way will be automatically plotted, and their legend strings will be intelligently inferred.

In `next()`, we simply check if the faster moving average just crossed over the slower one. If it did and upwards, we close the possible short position and go long; if it did and downwards, we close the open long position and go short. Note, we don't adjust order size, so *Backtesting* assumes *maximal possible position*. We use `backtesting.lib.crossover()` instead of writing more obscure and confusing conditions such as:
"""

# Commented out IPython magic to ensure Python compatibility.
# %%script echo
# 
#     def next(self):
#         if (self.sma1[-2] < self.sma2[-2] and
#                 self.sma1[-1] > self.sma2[-1]):
#             self.position.close()
#             self.buy()
# 
#         elif (self.sma1[-2] > self.sma2[-2] and    # Ugh!
#               self.sma1[-1] < self.sma2[-1]):
#             self.position.close()
#             self.sell()

"""In `init()`, the whole series of points was available, whereas in `next()`, the length of `self.data` and all declared indicators is adjusted on each `next()` call so that `array[-1]` (e.g. `self.data.Close[-1]` or `self.sma1[-1]` always  contains the most recent value, `array[-2]` the previous value, etc. (ordinary Python indexing of ascending-sorted 1D arrays).

**NOTE:** `self.data` and any indicators wrapped with `self.I` (e.g. `self.sma1`) are NumPy arrays for performance reasons. If you prefer pandas Series or DataFrame objects, use `Strategy.data.<column>.s` or `Strategy.data.df` accessors respectively. You could also construct the series manually, e.g. `pd.Series(self.data.Close, index = self.data.index)`.

Might avoid `self.position.close()` calls if we primed the `Backtest` instance with `Backtest(..., exclusive_orders = True)`.

## Backtesting

Let's see how our strategy performs on historical Google data. The `Backtest` instance is initialized with OHLC data and a strategy *class* (see API reference for additional options), and we begin with 10,000 units of cash and set broker's commission to realistic 0.2%.
"""

from backtesting import Backtest

bt = Backtest(GOOG, SmaCross, cash = 10_000, commission = 0.002)
stats = bt.run()
stats

"""`Backtest.run()` method returns a pandas Series of simulation results and statistics associated with our strategy. We see that this simple strategy makes almost 600% return in the period of 9 years, with maximum drawdown of 33% and with longest drawdown period spanning almost 2 years ...

`Backtest.plot()` emthod provides the same insights in a more visual form
"""

bt.plot()

"""## Optimization
hard-coded 2 lag parameters `n1` and `n2` into our strategy above. However, the strategy may work better with 15 - 30 or some other cross-over. **Declared parameters as optimizable by making them class variables**.

Optimize the 2 parameters by calling `Backtest.optimize()` method with each parameter a keyword argument pointing to its pool of possible values to test. Parameter `n1` is tested for values in range between 5 and 30 and parameter `n2` for values between 10 and 70, respectively. Some combos of values of the 2 parameters are invalid, i.e. `n1` should not be *larger than* or equal to `n2`. Limit admissible parameter combos with an *ad hoc* constraint function, which takes in the parameters and returns `True` (i.e. admissible) whenever `n1` is less than `n2`. Additionally, search for such parameter combo that maximizes return over the observed period. We could instead choose to optimize any other key from the returned `stats` series.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# stats = bt.optimize(n1=range(5, 30, 5),
#                     n2=range(10, 70, 5),
#                     maximize='Equity Final [$]',
#                     constraint=lambda param: param.n1 < param.n2)
# stats

stats

# n1 = 10, n2 = 15
stats._strategy

bt.plot(plot_volume=False, plot_pl=False)

"""Strategy optimization managed to up its initial performance *on in-sample data* by almost 50% and even beat simple buy & hold. In real life optimization, however, do **take steps to avoid overfitting**

## Trade data

In addition to backtest statistics returned by `Backtest.run()` shown above, you can look into *individual trade returns* and the changing equity curve and drawdown by inspecting last few internal keys in the result series.
"""

stats.tail()

stats['_equity_curve']  # Contains equity/drawdown curves. DrawdownDuration is only defined at ends of DD periods.

stats['_trades']  # Contains individual trade data

GOOG

data = pd.read_csv('AMD.csv')

AMD = data

btamd = Backtest(AMD, SmaCross, cash = 10_000, commission = 0.002)
stats = btamd.run()
stats

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# statsamd = btamd.optimize(n1=range(5, 30, 5),
#                     n2=range(10, 70, 5),
#                     maximize='Equity Final [$]',
#                     constraint=lambda param: param.n1 < param.n2)
# statsamd

statsamd._strategy

# simple SMA crossover strategy optimization doesn't beat Buy and hold for AMD
statsamd

"""# Library of Composable base strategies


"""

from backtesting.test import SMA

"""Part of this software distribution is `backtesting.lib` module that contains various reusable utilities for strategy development. Some of those utilities are composable base strategies we can extend and build upon.

We import and extend 2 of those strategies here:
- `SignalStrategy` which decides upon a single signal vector whether to buy into a position, akin to vectorized backtesting engines, and 
- `TrailingStrategy` which auto trails the current price with a stop-loss order some multiple of average true range (ATR) away.?}
"""

import pandas as pd
from backtesting.lib import SignalStrategy, TrailingStrategy

class SmaCross(SignalStrategy, TrailingStrategy):
  n1 = 10
  n2 = 25

  def init(self):
    # In init() and in next() it is important to call the
    # super method to properly initialize the parent classes
    super().init()
     
    # Precompute the two moving averages
    sma1 = self.I(SMA, self.data.Close, self.n1)
    sma2 = self.I(SMA, self.data.Close, self.n2)

    # Where sma1 crosses sma2 upwards. Diff gives us [-1,0, *1*]
    signal = (pd.Series(sma1) > sma2).astype(int).diff().fillna(0)
    signal = signal.replace(-1, 0)  # Upwards/long only

    # Use 95% of available liquidity (at the time) on each order.
    # (Leaving a value of 1. would instead buy a single share.)
    entry_size = signal * .95
                
    # Set order entry sizes using the method provided by 
    # `SignalStrategy`. See the docs.
    self.set_signal(entry_size=entry_size)
        
    # Set trailing stop-loss to 2x ATR using
    # the method provided by `TrailingStrategy`
    self.set_trailing_sl(2)

# from backtesting import Backtest
# from backtesting.test import GOOG

bt = Backtest(GOOG, SmaCross, commission=.002)

bt.run()
bt.plot()

bt.run()

"""# Multiple Time Frames"""

def SMA(array, n):
    """Simple moving average"""
    return pd.Series(array).rolling(n).mean()


def RSI(array, n):
    """Relative strength index"""
    # Approximate; good enough
    gain = pd.Series(array).diff()
    loss = gain.copy()
    gain[gain < 0] = 0
    loss[loss > 0] = 0
    rs = gain.ewm(n).mean() / loss.abs().ewm(n).mean()
    return 100 - 100 / (1 + rs)

"""Strategy:
Buy when:
- weekly RSI(30) >= daily RSI(30) > 70
- Close > MA(10) > MA(20) > MA(50) > MA(100)

Close Position when:
- Daily close is more than 2% *below* MA(10)
- 8% fixed stop loss is hit

Need to provide bars data in the lowest time frame (i.e. daily) and resample it to any higher time frame (i.e. weekly) that our strategy requires.
"""

from backtesting import Strategy, Backtest
from backtesting.lib import resample_apply


class System(Strategy):
    d_rsi = 30  # Daily RSI lookback periods
    w_rsi = 30  # Weekly
    level = 70
    
    def init(self):
        # Compute moving averages the strategy demands
        self.ma10 = self.I(SMA, self.data.Close, 10)
        self.ma20 = self.I(SMA, self.data.Close, 20)
        self.ma50 = self.I(SMA, self.data.Close, 50)
        self.ma100 = self.I(SMA, self.data.Close, 100)
        
        # Compute daily RSI(30)
        self.daily_rsi = self.I(RSI, self.data.Close, self.d_rsi)
        
        # To construct weekly RSI, we can use `resample_apply()`
        # helper function from the library
        self.weekly_rsi = resample_apply(
            'W-FRI', RSI, self.data.Close, self.w_rsi)
        
        
    def next(self):
        price = self.data.Close[-1]
        
        # If we don't already have a position, and
        # if all conditions are satisfied, enter long.
        if (not self.position and
            self.daily_rsi[-1] > self.level and
            self.weekly_rsi[-1] > self.level and
            self.weekly_rsi[-1] > self.daily_rsi[-1] and
            self.ma10[-1] > self.ma20[-1] > self.ma50[-1] > self.ma100[-1] and
            price > self.ma10[-1]):
            
            # Buy at market price on next open, but do
            # set 8% fixed stop loss.
            self.buy(sl=.92 * price)
        
        # If the price closes 2% or more below 10-day MA
        # close the position, if any.
        elif price < .98 * self.ma10[-1]:
            self.position.close()

backtest = Backtest(GOOG, System, commission=.002)
backtest.run()

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# backtest.optimize(d_rsi=range(10, 35, 5),
#                   w_rsi=range(10, 35, 5),
#                   level=range(30, 80, 10))

backtest.plot()

"""In conclusion, to test strategies on multiple time frames, you need to pass in OHLC data in the lowest time frame, then resample it to higher time frames, apply the indicators, then resample back to the lower time frame, filling in the in-betweens. Which is what the function `backtesting.lib.resample_apply()` does for you."""

